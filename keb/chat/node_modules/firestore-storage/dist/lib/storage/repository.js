"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseRepository = void 0;
const firestore_storage_core_1 = require("firestore-storage-core");
const query_1 = require("./query");
const utils_1 = require("./utils");
class BaseRepository extends firestore_storage_core_1.BaseRepository {
    constructor(firestore) {
        super();
        this.firestore = firestore;
    }
    fromFirestoreToObject(snapshot) {
        if (!snapshot.exists) {
            return null;
        }
        const transformer = this.getTransformer();
        return transformer.fromFirestoreToObject(snapshot.data(), {
            id: snapshot.id,
            rawPath: snapshot.ref.path,
        });
    }
    /**
     *
     */
    async findById(ids) {
        const doc = await this.firestore.doc(this.getDocumentPath(ids)).get();
        return this.fromFirestoreToObject(doc);
    }
    async getById(ids) {
        const doc = await this.findById(ids);
        if (doc) {
            return doc;
        }
        throw new firestore_storage_core_1.FirestoreStorageError(this.getPath().path(), ids);
    }
    async find(attributes, ids) {
        const documents = await this.list(attributes, ids);
        return documents[0] || null;
    }
    async get(attributes, ids) {
        const doc = await this.find(attributes, ids);
        if (doc) {
            return doc;
        }
        throw new firestore_storage_core_1.FirestoreStorageError(this.getPath().path(), ids);
    }
    list(attributes, ids) {
        return this.query((q) => {
            return q.whereAll(attributes);
        }, ids);
    }
    async query(cb, ids) {
        const path = this.getCollectionPath(ids);
        const query = new query_1.Query(this.firestore.collection(path));
        const result = await cb(query).execute();
        if (result.empty) {
            return [];
        }
        return result.docs.map((doc) => {
            return this.fromFirestoreToObject(doc);
        });
    }
    async groupQuery(cb) {
        const group = this.firestore.collectionGroup(this.getCollectionName());
        const result = await (cb ? cb(new query_1.Query(group)).execute() : group.get());
        if (result.empty) {
            return [];
        }
        return result.docs.map((doc) => {
            return this.fromFirestoreToObject(doc);
        });
    }
    async findAll(documentIds, ids) {
        if (documentIds.length === 0) {
            return [];
        }
        const path = this.getCollectionPath(ids);
        const docRefs = documentIds.map((id) => {
            return this.firestore.collection(path).doc(id);
        });
        const result = await this.firestore.getAll(...docRefs);
        return result.map((document) => {
            return this.fromFirestoreToObject(document);
        });
    }
    async getAll(documentIds, ids) {
        const all = await this.findAll(documentIds, ids);
        for (const id of documentIds) {
            const doc = all.find((d) => d?.id === id);
            if (!doc) {
                throw new firestore_storage_core_1.FirestoreStorageError(this.getPath().path(), ids);
            }
        }
        return all;
    }
    async count(cb, ids) {
        const path = this.getCollectionPath(ids);
        const query = new query_1.Query(this.firestore.collection(path));
        const result = await cb(query).count().get();
        return result.data().count;
    }
    async create(data, ids) {
        return this.applyToDocRef(data, ids, (doc, data) => {
            return doc.create(data);
        });
    }
    /**@deprecated use upsert instead*/
    async save(data, ids) {
        return this.applyToDocRef(data, ids, (doc, data) => {
            return doc.set(data, {
                merge: true,
            });
        });
    }
    async upsert(data, ids) {
        return this.applyToDocRef(data, ids, (doc, data) => {
            return doc.set(data, {
                merge: true,
            });
        });
    }
    async write(data, ids) {
        return this.applyToDocRef(data, ids, (doc, data) => {
            return doc.set(data, {
                merge: false,
            });
        });
    }
    async update(data, ids) {
        return this.applyToDocRef(data, ids, (doc, data) => {
            return doc.update(data);
        });
    }
    async applyToDocRef(data, ids, cb) {
        return (0, utils_1.applyToDoc)(this.firestore, this, data, ids, async (id, data, docRef) => {
            try {
                await cb(docRef, data);
            }
            catch (err) {
                throw new firestore_storage_core_1.FirestoreStorageError(this.getPath().path(), ids, err.message);
            }
            const doc = await docRef.get();
            return this.fromFirestoreToObject(doc);
        });
    }
    async delete(ids) {
        const path = this.getDocumentPath(ids);
        await this.firestore.doc(path).delete();
    }
    generateId() {
        return this.firestore.collection('any').doc().id;
    }
}
exports.BaseRepository = BaseRepository;
//# sourceMappingURL=repository.js.map