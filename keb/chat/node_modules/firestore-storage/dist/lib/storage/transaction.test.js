"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const definitions_test_1 = require("./definitions.test");
const test_utils_1 = require("./test-utils");
const transaction_1 = require("./transaction");
require("should");
describe('Transaction', function () {
    let firestore;
    let modelRepo;
    let accountRepo;
    let userRepo;
    (0, test_utils_1.createFirestoreTests)(this, (f) => {
        firestore = f;
        modelRepo = new definitions_test_1.ModelRepository(firestore);
        userRepo = new definitions_test_1.UserRepository(firestore);
        accountRepo = new definitions_test_1.AccountRepository(firestore);
    });
    it('should create a document', async () => {
        const acc = await accountRepo.create({
            name: 'Test',
        });
        await (0, transaction_1.runFirestoreTransaction)(firestore, async (trx) => {
            const a = await trx.getById(accountRepo, { accountId: acc.id });
            trx.create(accountRepo, {
                name: a.name + '2',
            }, undefined);
        });
    });
    it('should query documents', async () => {
        const create = async (name) => {
            const acc = await accountRepo.create({
                name,
            });
            return acc.id;
        };
        const prefix = `acc-${Date.now()}`;
        const [a1, a2, a3, a4] = await Promise.all([
            create(prefix + 'Test1'),
            create(prefix + 'Test2'),
            create(prefix + 'Test3'),
            create(prefix + 'Test1'),
        ]);
        const ids = await (0, transaction_1.runFirestoreTransaction)(firestore, async (trx) => {
            const accounts = await trx.query(accountRepo, (qb) => {
                return qb.whereAll({
                    name: prefix + 'Test1',
                });
            }, undefined);
            return accounts.map((a) => a.id);
        });
        ids.sort().should.eql([a1, a4].sort());
    });
});
//# sourceMappingURL=transaction.test.js.map