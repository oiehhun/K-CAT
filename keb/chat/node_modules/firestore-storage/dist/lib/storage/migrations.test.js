"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("should");
const migrations_1 = require("./migrations");
const definitions_test_1 = require("./definitions.test");
const test_utils_1 = require("./test-utils");
describe('Migrations', function () {
    class MyProjectMigrations extends migrations_1.Migrations {
        constructor(firestore) {
            super(firestore);
            this.accountRepo = new definitions_test_1.AccountRepository(firestore);
        }
        getVersion() {
            return 1;
        }
        onUpgrade(toVersion) {
            switch (toVersion) {
                case 1:
                    return this.appendToName();
            }
        }
        async appendToName() {
            const accounts = await this.accountRepo.list(null);
            for (const account of accounts) {
                await this.accountRepo.update({
                    id: account.id,
                    name: `${account.name}-1`,
                });
            }
        }
    }
    let migrations;
    (0, test_utils_1.createFirestoreTests)(this, (firestore) => {
        migrations = new MyProjectMigrations(firestore);
    });
    it('should run a simple migration', async () => {
        await migrations.readVersion().should.resolvedWith(0);
        let a1 = await migrations.accountRepo.save({
            name: 'acc1',
        });
        let a2 = await migrations.accountRepo.save({
            name: 'acc2',
        });
        await migrations.upgrade();
        a1 = await migrations.accountRepo.getById({ accountId: a1.id });
        a2 = await migrations.accountRepo.getById({ accountId: a2.id });
        a1.name.should.eql('acc1-1');
        a2.name.should.eql('acc2-1');
        await migrations.readVersion().should.resolvedWith(1);
    });
});
//# sourceMappingURL=migrations.test.js.map