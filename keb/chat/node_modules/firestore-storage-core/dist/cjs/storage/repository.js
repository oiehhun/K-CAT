"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Repository = exports.BaseRepository = void 0;
require("reflect-metadata");
const transformer_1 = require("./transformer");
const transformerMetaKey = 'firestore:transformer';
const pathMetaKey = 'firestore:path';
/**
 * Base class for platform independent repositories. Contains methods accessing its metadata supplied
 * via the Typescript @Repository decorator
 */
class BaseRepository {
    constructor() {
        this.collectionPath = Reflect.getMetadata(pathMetaKey, this.constructor);
        if (!this.collectionPath) {
            throw new Error(`Unable to get path for ${this.constructor.name}. Did you add the @Repository decorator`);
        }
        this.transformer = Reflect.getMetadata(transformerMetaKey, this.constructor);
    }
    toFirestoreDocument(data) {
        return this.getTransformer().toFirestoreDocument(data);
    }
    /**
     * Returns the path to the document as a string
     * @param ids - A map containing all ids up to the document itself
     */
    getDocumentPath(ids) {
        return this.getPath().doc(ids);
    }
    /**
     * Returns the path to the collection as a string
     * @param ids - A map containing all ids excluding the last documents id
     */
    getCollectionPath(ids) {
        return this.getPath().collection(ids);
    }
    /**
     * Returns the standalone collection name
     */
    getCollectionName() {
        return this.getPath().collectionName;
    }
    getPath() {
        return this.collectionPath;
    }
    getTransformer() {
        return this.transformer;
    }
}
exports.BaseRepository = BaseRepository;
function Repository(args) {
    return (target) => {
        Reflect.defineMetadata(pathMetaKey, args.path, target);
        Reflect.defineMetadata(transformerMetaKey, args.transformer || transformer_1.DEFAULT_DOCUMENT_TRANSFORMER, target);
    };
}
exports.Repository = Repository;
//# sourceMappingURL=repository.js.map